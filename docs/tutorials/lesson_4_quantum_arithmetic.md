# PySparq 量子计算教程 - 量子算术运算

## 案例

### 1. **量子叠加态的创建**
通过对寄存器 `r1` 应用全局哈达玛门 (`spq.Hadamard_Int_Full`)，我们创建了均匀叠加态：
```python
spq.Hadamard_Int_Full(r1)(state)
```
此时 `r1` 的量子态覆盖 `0~15` 的所有整数（4比特寄存器），每个值的振幅为 `0.25`（即概率幅 `1/√16 = 1/4`）。


### 2. **常数加法操作**
通过 `spq.Add_UInt_ConstUInt` 对 `r1` 加常数 `2`，结果存入 `r2`：
```python
spq.Add_UInt_ConstUInt(r1, 2, r2)(state)
```
结果中 `r2 = (r1 + 2) mod 16`，例如：
- `r1=0 → r2=2`
- `r1=15 → r2=1`（溢出后取模）


### 3. **寄存器间加法操作**
通过 `spq.Add_UInt_UInt` 将 `r1` 和 `r2` 相加，结果存入 `r3`：
```python
spq.Add_UInt_UInt(r1, r2, r3)(state)
```
此时 `r3 = (r1 + r2) mod 16`。由于 `r2 = r1 + 2`，实际效果为 `r3 = (2*r1 + 2) mod 16`，例如：
- `r1=5 → r2=7 → r3=12`
- `r1=7 → r2=9 → r3=0`（溢出）


### 4. **赋值与交换操作**
- **赋值操作 (`spq.Assign`)**  
  将 `r1` 的值复制到 `r4`：
  ```python
  spq.Assign(r1, r4)(state)
  ```
  这等价于对每个量子比特执行 CNOT 门，确保 `r4` 的量子态与 `r1` 完全一致。

- **交换操作 (`spq.Swap_General_General`)**  
  交换 `r4` 和 `r2` 的值：
  ```python
  spq.Swap_General_General(r4, r2)(state)
  ```
  量子交换操作按比特交换两个寄存器的状态（逻辑等同于经典 SWAP 操作）。


### 5. **结果验证**
最终的量子态输出显示：
1. **赋值后**：`r4` 的值与 `r1` 完全一致。
2. **交换后**：`r4` 的值变为原 `r2` 的值，而 `r2` 的值变为原 `r4`（即原 `r1`）。

这表明赋值和交换操作均按预期工作，验证了量子态的正确性。


### 6. **溢出处理机制**
所有算术操作均遵循 **模运算**（模数为 `2^size`，此处 `size=4`，故模 `16`）。例如：
- `15 + 2 = 17 → 17 mod 16 = 1`
- `7 + 9 = 16 → 16 mod 16 = 0`

这种机制避免了量子比特数的限制带来的错误，确保计算结果在寄存器范围内。


### 7. **扩展性提示**
pysparq 支持更多量子算术运算，例如：
- **移位操作**: `spq.ShiftLeft`



通过以上步骤，我们验证了 pysparq 在寄存器层面执行量子算术运算的能力，其语法简洁且符合直觉，显著降低了量子编程的复杂度。